<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Medusa Inteligente ‚Äì Grupo Fiancar</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at center, #030712 0%, #000 90%);
      font-family: "Inter", sans-serif;
      color: #7dcaff;
    }
    canvas {
      position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh;
      display: block; cursor: none;
    }

    /* Men√∫ hamburguesa */
    .menu-btn {
      position: absolute;
      top: 15px; right: 20px;
      z-index: 10;
      width: 32px; height: 24px;
      cursor: pointer;
      display: flex; flex-direction: column;
      justify-content: space-between;
    }
    .menu-btn div {
      height: 4px;
      background: #7dcaff;
      border-radius: 2px;
      transition: 0.3s;
    }
    .menu {
      position: absolute;
      top: 55px; right: 15px;
      width: 270px;
      background: rgba(0,0,0,0.85);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.6);
      padding: 16px;
      display: none;
      flex-direction: column;
      gap: 10px;
      z-index: 15;
      backdrop-filter: blur(8px);
    }
    .menu.open { display: flex; }
    .menu label {
      font-size: 0.9em;
      color: #9cdcff;
      margin-bottom: 2px;
    }
    .menu input[type="color"] {
      width: 100%;
      height: 30px;
      border: none;
      border-radius: 6px;
      background: transparent;
      cursor: pointer;
    }
    .menu input[type="checkbox"] {
      transform: scale(1.2);
      margin-right: 6px;
    }
    .url-box {
      display: flex;
      flex-direction: column;
    }
    .url-box input {
      padding: 6px 8px;
      border-radius: 6px;
      border: none;
      background: #0a1724;
      color: #7dcaff;
      font-size: 0.8em;
      outline: none;
    }
    .status {
      font-size: 0.8em;
      margin-top: 4px;
      color: #9cdcff;
      opacity: 0.8;
    }

    /* Chat */
    .chat {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 480px;
      background: rgba(0,0,0,0.6);
      border-top-left-radius: 14px;
      border-top-right-radius: 14px;
      box-shadow: 0 -2px 18px rgba(0,0,0,0.6);
      display: none;
      flex-direction: column;
      padding: 12px;
      color: #cde9ff;
      z-index: 20;
      backdrop-filter: blur(10px);
    }
    .messages {
      flex: 1;
      max-height: 260px;
      overflow-y: auto;
      font-size: 0.9em;
      margin-bottom: 8px;
    }
    .msg {
      margin: 4px 0;
      padding: 6px 10px;
      border-radius: 8px;
      line-height: 1.3;
    }
    .msg.user { background: rgba(125,202,255,0.15); text-align: right; }
    .msg.bot { background: rgba(125,202,255,0.05); text-align: left; }
    .chat input {
      padding: 8px 10px;
      border-radius: 8px;
      border: none;
      background: rgba(255,255,255,0.1);
      color: #fff;
      width: 100%;
      outline: none;
      font-family: inherit;
    }
  </style>
</head>
<body>

  <canvas id="canvas"></canvas>

  <!-- Men√∫ hamburguesa -->
  <div class="menu-btn" id="menuBtn">
    <div></div><div></div><div></div>
  </div>

  <div class="menu" id="menu">
    <div>
      <label for="color">üé® Color manual</label>
      <input type="color" id="color" value="#7dcaff">
    </div>

    <div>
      <label><input type="checkbox" id="autoColor"> Cambio autom√°tico</label>
    </div>

    <div class="url-box">
      <label for="docUrl">üóÇÔ∏è URL documento</label>
      <input type="text" id="docUrl" placeholder="https://ejemplo.com/documento">
      <div class="status" id="status">Sin documento cargado</div>
    </div>
  </div>

  <!-- Chat -->
  <div class="chat" id="chat">
    <div class="messages" id="messages"></div>
    <input type="text" id="question" placeholder="Escrib√≠ tu pregunta y presion√° Enter...">
  </div>

  <script>
    const BACKEND_URL = "https://TU_DOMINIO/ask"; // üîß Cambi√° esto por tu endpoint real

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d", { alpha: true });
    const colorPicker = document.getElementById("color");
    const autoColor = document.getElementById("autoColor");
    const menu = document.getElementById("menu");
    const menuBtn = document.getElementById("menuBtn");
    const docUrlInput = document.getElementById("docUrl");
    const status = document.getElementById("status");
    const chat = document.getElementById("chat");
    const messages = document.getElementById("messages");
    const question = document.getElementById("question");

    menuBtn.addEventListener("click", () => menu.classList.toggle("open"));

    // === Color control ===
    let mainColor = colorPicker.value;
    let autoHue = 200;
    let autoMode = false;
    colorPicker.addEventListener("input", e => mainColor = e.target.value);
    autoColor.addEventListener("change", e => autoMode = e.target.checked);

    function hslToHex(h, s, l) {
      s /= 100; l /= 100;
      const a = s * Math.min(l, 1 - l);
      const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(-1, Math.min(k - 3, Math.min(9 - k, 1)));
        return Math.round(255 * color);
      };
      return "#" + [f(0), f(8), f(4)]
        .map(x => x.toString(16).padStart(2, "0")).join("");
    }
    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return { r, g, b };
    }

    // === Documento remoto ===
    let documentoCargado = "";

    docUrlInput.addEventListener("change", async () => {
      const url = docUrlInput.value.trim();
      if (!url) return;
      status.textContent = "Cargando documento...";
      try {
        const proxy = "https://api.allorigins.win/get?url=" + encodeURIComponent(url);
        const res = await fetch(proxy);
        const data = await res.json();
        const html = data.contents;

        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        documentoCargado = doc.body.innerText.replace(/\s+/g, " ").trim();

        status.textContent = "‚úÖ Documento cargado correctamente.";
        chat.style.display = "flex";
      } catch (err) {
        console.error(err);
        status.textContent = "‚ö†Ô∏è Error al leer el documento.";
      }
    });

    // === Chat ===
    question.addEventListener("keypress", e => {
      if (e.key === "Enter" && question.value.trim()) {
        const query = question.value.trim();
        addMessage(query, "user");
        question.value = "";
        medusaRespond(query);
      }
    });

    function addMessage(text, sender) {
      const div = document.createElement("div");
      div.className = `msg ${sender}`;
      div.textContent = text;
      messages.appendChild(div);
      messages.scrollTop = messages.scrollHeight;
    }

    async function medusaRespond(query) {
      if (!documentoCargado) {
        addMessage("‚ö†Ô∏è Carg√° primero un documento.", "bot");
        return;
      }
      addMessage("üí≠ Pensando...", "bot");
      try {
        const res = await fetch(BACKEND_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            context: documentoCargado.slice(0, 8000),
            question: query
          })
        });
        const data = await res.json();
        messages.lastChild.textContent = data.reply || "‚ö° No obtuve respuesta.";
        pulse = 6;
      } catch (err) {
        console.error(err);
        messages.lastChild.textContent = "‚ö†Ô∏è Error al conectar con ChatGPT.";
      }
    }

    // === Canvas y animaci√≥n ===
    function resizeCanvas() {
      canvas.width = window.innerWidth * devicePixelRatio;
      canvas.height = window.innerHeight * devicePixelRatio;
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const pointer = { x: innerWidth / 2, y: innerHeight / 2 };
    const core = { x: pointer.x, y: pointer.y, vx: 0, vy: 0, radius: 30 };
    let lastMove = Date.now();

    window.addEventListener("mousemove", e => updatePointer(e.clientX, e.clientY));
    window.addEventListener("touchmove", e => {
      e.preventDefault();
      const t = e.touches[0];
      updatePointer(t.clientX, t.clientY);
    }, { passive: false });

    function updatePointer(x, y) {
      pointer.x = x;
      pointer.y = y;
      lastMove = Date.now();
    }

    class Tentacle {
      constructor(core, angle) {
        this.core = core; this.angle = angle;
        this.length = 100 + Math.random() * 80;
        this.segments = [];
        this.noise = Math.random() * 100;
        this.phase = Math.random() * Math.PI * 2;
        const segCount = Math.floor(this.length / 10);
        for (let i = 0; i < segCount; i++) this.segments.push({ x: core.x, y: core.y });
      }
      update(t) {
        const baseAngle = this.angle + Math.sin(t * 0.001 + this.phase) * 0.3;
        const dirX = Math.cos(baseAngle) * 180;
        const dirY = Math.sin(baseAngle) * 180;
        let prevX = this.core.x, prevY = this.core.y;
        const segLen = 10;
        for (let i = 0; i < this.segments.length; i++) {
          const seg = this.segments[i];
          const pct = i / this.segments.length;
          const wave = Math.sin(t * 0.004 + this.noise + i * 0.3) * 60 * (1 - pct);
          const swayAngle = baseAngle + Math.PI / 2;
          const targetX = this.core.x + dirX * pct + wave * Math.cos(swayAngle);
          const targetY = this.core.y + dirY * pct + wave * Math.sin(swayAngle);
          const dx = targetX - prevX, dy = targetY - prevY;
          const dist = Math.hypot(dx, dy) || 1;
          const ratio = segLen / dist;
          seg.x = prevX + dx * ratio;
          seg.y = prevY + dy * ratio;
          prevX = seg.x; prevY = seg.y;
        }
      }
      draw(ctx, flicker) {
        const { r, g, b } = hexToRgb(mainColor);
        const grad = ctx.createLinearGradient(this.core.x, this.core.y, this.segments.at(-1).x, this.segments.at(-1).y);
        grad.addColorStop(0, `rgba(${r},${g},${b},${0.8 + flicker * 0.2})`);
        grad.addColorStop(1, `rgba(${r * 0.4},${g * 0.4},${b * 0.4},${0.3 + flicker * 0.2})`);
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.beginPath();
        ctx.moveTo(this.core.x, this.core.y);
        for (const p of this.segments) ctx.lineTo(p.x, p.y);
        ctx.strokeStyle = grad;
        ctx.lineWidth = 2 + flicker * 2;
        ctx.shadowBlur = 25 + flicker * 45;
        ctx.shadowColor = `rgba(${r},${g},${b},0.7)`;
        ctx.stroke();
        ctx.restore();
      }
    }

    const tentacles = Array.from({ length: 65 }, (_, i) => new Tentacle(core, (i / 65) * Math.PI * 2));
    let pulse = 0;

    function animate(t) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (autoMode) {
        autoHue = (autoHue + 0.5) % 360;
        mainColor = hslToHex(autoHue, 100, 65);
        colorPicker.value = mainColor;
      }

      const timeSinceMove = Date.now() - lastMove;
      const flicker = Math.random() * 0.6 + pulse * 0.3;
      pulse = Math.max(pulse - 0.05, 0);

      const targetX = pointer.x + Math.sin(t * 0.001) * 100 * Math.min(timeSinceMove / 2000, 1);
      const targetY = pointer.y + Math.cos(t * 0.0013) * 80 * Math.min(timeSinceMove / 2000, 1);

      const ax = (targetX - core.x) * 0.01;
      const ay = (targetY - core.y) * 0.01;
      core.vx += ax; core.vy += ay;
      core.vx *= 0.95; core.vy *= 0.95;
      core.x += core.vx; core.y += core.vy;

      const { r, g, b } = hexToRgb(mainColor);

      ctx.save();
      const gGlow = ctx.createRadialGradient(core.x, core.y, 0, core.x, core.y, 150);
      gGlow.addColorStop(0, `rgba(${r},${g},${b},${0.9 + flicker * 0.2})`);
      gGlow.addColorStop(0.3, `rgba(${r * 0.7},${g * 0.7},${b * 0.7},${0.3 + flicker * 0.2})`);
      gGlow.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = gGlow;
      ctx.beginPath();
      ctx.arc(core.x, core.y, core.radius * (3.5 + flicker * 0.8), 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.beginPath();
      ctx.fillStyle = `rgba(${r},${g},${b},${0.9 + flicker * 0.2})`;
      ctx.arc(core.x, core.y, core.radius * (1.1 + flicker * 0.1), 0, Math.PI * 2);
      ctx.fill();

      for (const tacle of tentacles) {
        tacle.update(t);
        tacle.draw(ctx, flicker);
      }

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  </script>
</body>
</html>
