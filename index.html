<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Medusa Inteligente ‚Äì Grupo Fiancar</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at center, #030712 0%, #000 90%);
      font-family: "Inter", sans-serif;
      color: #7dcaff;
    }
    canvas {
      position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh;
      display: block; cursor: none;
    }

    /* Men√∫ hamburguesa */
    .menu-btn {
      position: absolute;
      top: 15px; right: 20px;
      z-index: 10;
      width: 32px; height: 24px;
      cursor: pointer;
      display: flex; flex-direction: column;
      justify-content: space-between;
    }
    .menu-btn div {
      height: 4px;
      background: #7dcaff;
      border-radius: 2px;
      transition: 0.3s;
    }
    .menu {
      position: absolute;
      top: 55px; right: 15px;
      width: 250px;
      background: rgba(0,0,0,0.8);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.6);
      padding: 16px;
      display: none;
      flex-direction: column;
      gap: 10px;
      z-index: 15;
      backdrop-filter: blur(8px);
    }
    .menu.open { display: flex; }
    .menu label {
      font-size: 0.9em;
      color: #9cdcff;
      margin-bottom: 2px;
    }
    .menu input[type="color"] {
      width: 100%;
      height: 30px;
      border: none;
      border-radius: 6px;
      background: transparent;
      cursor: pointer;
    }
    .menu input[type="checkbox"] {
      transform: scale(1.2);
      margin-right: 6px;
    }
    .url-box {
      display: flex;
      flex-direction: column;
    }
    .url-box input {
      padding: 6px 8px;
      border-radius: 6px;
      border: none;
      background: #0a1724;
      color: #7dcaff;
      font-size: 0.8em;
      outline: none;
    }
  </style>
</head>
<body>

  <canvas id="canvas"></canvas>

  <!-- Men√∫ hamburguesa -->
  <div class="menu-btn" id="menuBtn">
    <div></div><div></div><div></div>
  </div>

  <div class="menu" id="menu">
    <div>
      <label for="color">üé® Color manual</label>
      <input type="color" id="color" value="#7dcaff">
    </div>

    <div>
      <label><input type="checkbox" id="autoColor"> Cambio autom√°tico</label>
    </div>

    <div class="url-box">
      <label for="docUrl">üóÇÔ∏è URL documento</label>
      <input type="text" id="docUrl" placeholder="https://ejemplo.com/documento">
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d", { alpha: true });
    const colorPicker = document.getElementById("color");
    const autoColor = document.getElementById("autoColor");
    const menu = document.getElementById("menu");
    const menuBtn = document.getElementById("menuBtn");

    // Toggle men√∫
    menuBtn.addEventListener("click", () => {
      menu.classList.toggle("open");
      menuBtn.classList.toggle("active");
    });

    // Color din√°mico
    let mainColor = colorPicker.value;
    let autoHue = 200;
    let autoMode = false;

    colorPicker.addEventListener("input", (e) => {
      mainColor = e.target.value;
    });

    autoColor.addEventListener("change", (e) => {
      autoMode = e.target.checked;
    });

    function hslToHex(h, s, l) {
      s /= 100; l /= 100;
      const a = s * Math.min(l, 1 - l);
      const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(-1, Math.min(k - 3, Math.min(9 - k, 1)));
        return Math.round(255 * color);
      };
      return "#" + [f(0), f(8), f(4)]
        .map(x => x.toString(16).padStart(2, "0"))
        .join("");
    }

    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return { r, g, b };
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth * devicePixelRatio;
      canvas.height = window.innerHeight * devicePixelRatio;
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const pointer = { x: innerWidth / 2, y: innerHeight / 2 };
    const core = { x: pointer.x, y: pointer.y, vx: 0, vy: 0, radius: 30 };
    let lastMove = Date.now();

    window.addEventListener("mousemove", e => updatePointer(e.clientX, e.clientY));
    window.addEventListener("touchmove", e => {
      e.preventDefault();
      const t = e.touches[0];
      updatePointer(t.clientX, t.clientY);
    }, { passive: false });

    function updatePointer(x, y) {
      pointer.x = x;
      pointer.y = y;
      lastMove = Date.now();
    }

    class Tentacle {
      constructor(core, angle) {
        this.core = core; this.angle = angle;
        this.length = 100 + Math.random() * 80;
        this.segments = [];
        this.noise = Math.random() * 100;
        this.phase = Math.random() * Math.PI * 2;
        const segCount = Math.floor(this.length / 10);
        for (let i = 0; i < segCount; i++) this.segments.push({ x: core.x, y: core.y });
      }
      update(t) {
        const baseAngle = this.angle + Math.sin(t * 0.001 + this.phase) * 0.3;
        const dirX = Math.cos(baseAngle) * 180;
        const dirY = Math.sin(baseAngle) * 180;
        let prevX = this.core.x, prevY = this.core.y;
        const segLen = 10;
        for (let i = 0; i < this.segments.length; i++) {
          const seg = this.segments[i];
          const pct = i / this.segments.length;
          const wave = Math.sin(t * 0.004 + this.noise + i * 0.3) * 60 * (1 - pct);
          const swayAngle = baseAngle + Math.PI / 2;
          const targetX = this.core.x + dirX * pct + wave * Math.cos(swayAngle);
          const targetY = this.core.y + dirY * pct + wave * Math.sin(swayAngle);
          const dx = targetX - prevX, dy = targetY - prevY;
          const dist = Math.hypot(dx, dy) || 1;
          const ratio = segLen / dist;
          seg.x = prevX + dx * ratio;
          seg.y = prevY + dy * ratio;
          prevX = seg.x; prevY = seg.y;
        }
      }
      draw(ctx, flicker) {
        const { r, g, b } = hexToRgb(mainColor);
        const grad = ctx.createLinearGradient(this.core.x, this.core.y, this.segments.at(-1).x, this.segments.at(-1).y);
        grad.addColorStop(0, `rgba(${r},${g},${b},${0.8 + flicker * 0.2})`);
        grad.addColorStop(1, `rgba(${r * 0.4},${g * 0.4},${b * 0.4},${0.3 + flicker * 0.2})`);
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.beginPath();
        ctx.moveTo(this.core.x, this.core.y);
        for (const p of this.segments) ctx.lineTo(p.x, p.y);
        ctx.strokeStyle = grad;
        ctx.lineWidth = 2 + flicker * 2;
        ctx.shadowBlur = 25 + flicker * 45;
        ctx.shadowColor = `rgba(${r},${g},${b},0.7)`;
        ctx.stroke();
        ctx.restore();
      }
    }

    const tentacles = Array.from({ length: 65 }, (_, i) => new Tentacle(core, (i / 65) * Math.PI * 2));

    function animate(t) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (autoMode) {
        autoHue = (autoHue + 0.5) % 360;
        mainColor = hslToHex(autoHue, 100, 65);
        colorPicker.value = mainColor;
      }

      const timeSinceMove = Date.now() - lastMove;
      const flicker = Math.random() * 0.6;

      const targetX = pointer.x + Math.sin(t * 0.001) * 100 * Math.min(timeSinceMove / 2000, 1);
      const targetY = pointer.y + Math.cos(t * 0.0013) * 80 * Math.min(timeSinceMove / 2000, 1);

      const ax = (targetX - core.x) * 0.01;
      const ay = (targetY - core.y) * 0.01;
      core.vx += ax;
      core.vy += ay;
      core.vx *= 0.95;
      core.vy *= 0.95;
      core.x += core.vx;
      core.y += core.vy;

      const { r, g, b } = hexToRgb(mainColor);

      // Glow central
      ctx.save();
      const gGlow = ctx.createRadialGradient(core.x, core.y, 0, core.x, core.y, 150);
      gGlow.addColorStop(0, `rgba(${r},${g},${b},${0.9 + flicker * 0.2})`);
      gGlow.addColorStop(0.3, `rgba(${r * 0.7},${g * 0.7},${b * 0.7},${0.3 + flicker * 0.2})`);
      gGlow.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = gGlow;
      ctx.beginPath();
      ctx.arc(core.x, core.y, core.radius * (3.5 + flicker * 0.8), 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // N√∫cleo
      ctx.beginPath();
      ctx.fillStyle = `rgba(${r},${g},${b},${0.9 + flicker * 0.2})`;
      ctx.arc(core.x, core.y, core.radius * (1.1 + flicker * 0.1), 0, Math.PI * 2);
      ctx.fill();

      for (const tacle of tentacles) {
        tacle.update(t);
        tacle.draw(ctx, flicker);
      }

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  </script>
</body>
</html>
